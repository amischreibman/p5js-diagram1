<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Diagram</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #F2A900;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script>
    let baseDistance = 150;
    let wiggleSpeed = 0.01;
    let wiggleRadius = 20;
    let textShadowBlur = 0;
    let textShadowColor = 'white';
    let textMaxSizePercentage = 0.6;

    let centerNode;
    let surroundingNodes = [];
    let focusedNodeIndex = null; // חדש: משתנה לשמירת העיגול שנלחץ

    function setup() {
      createCanvas(windowWidth, windowHeight);
      noStroke();
      initNodes();
      textFont('Arial');
      textAlign(CENTER, CENTER);
      drawingContext.textBaseline = 'middle';
      drawingContext.textAlign = 'center';
      pixelDensity(1);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      initNodes();
    }

    function initNodes() {
      surroundingNodes = [];
      focusedNodeIndex = null;

      centerNode = {
        baseX: width / 2,
        baseY: height / 2,
        r: 180,
        currentR: 180,
        col: color(0, 102, 255),
        angleOffset: random(1000),
        label: 'מרכז'
      };

      let maxTries = 1000;
      while (surroundingNodes.length < 10 && maxTries > 0) {
        maxTries--;
        let angle = random(TWO_PI);
        let dist = random(baseDistance, baseDistance + 100);
        let r = random(50, 80);
        let x = centerNode.baseX + cos(angle) * dist;
        let y = centerNode.baseY + sin(angle) * dist;

        let overlaps = surroundingNodes.some(other => distFunc(x, y, other.baseX, other.baseY) < r / 2 + other.r / 2 + 20);
        if (overlaps) continue;

        surroundingNodes.push({
          angle,
          r,
          col: color(random(255), random(255), random(255)),
          angleOffset: random(1000),
          baseX: x,
          baseY: y,
          currentX: x,
          currentY: y,
          title: `כותרת ${surroundingNodes.length + 1}`,
          bodyText: `זהו הטקסט המורחב של עיגול ${surroundingNodes.length + 1}`
        });
      }
    }

    function draw() {
      background('#F2A900');

      // draw surrounding nodes
      for (let i = 0; i < surroundingNodes.length; i++) {
        let node = surroundingNodes[i];
        let offsetX = cos(frameCount * wiggleSpeed + node.angleOffset) * wiggleRadius;
        let offsetY = sin(frameCount * wiggleSpeed + node.angleOffset) * wiggleRadius;

        fill(0);
        ellipse(node.currentX + offsetX + 3, node.currentY + offsetY + 3, node.r);
        fill(node.col);
        ellipse(node.currentX + offsetX, node.currentY + offsetY, node.r);

        push();
        fill(0);
        noStroke();
        drawingContext.imageSmoothingEnabled = true;
        drawingContext.imageSmoothingQuality = 'high';

        let textSizeValue = min(node.r * textMaxSizePercentage, 20);
        textSize(textSizeValue);

        drawingContext.shadowColor = textShadowColor;
        drawingContext.shadowBlur = textShadowBlur;
        text(node.title, node.currentX + offsetX, node.currentY + offsetY);

        // אם זה העיגול שנבחר – נציג גם את הטקסט המורחב
        if (focusedNodeIndex === i) {
          textAlign(CENTER, TOP);
          textSize(14);
          text(node.bodyText, node.currentX + offsetX, node.currentY + offsetY + node.r / 2 + 10, 180);
        }

        pop();
      }

      // draw center node
      let centerOffsetX = cos(frameCount * wiggleSpeed + centerNode.angleOffset) * wiggleRadius;
      let centerOffsetY = sin(frameCount * wiggleSpeed + centerNode.angleOffset) * wiggleRadius;

      fill(0);
      ellipse(centerNode.baseX + centerOffsetX + 3, centerNode.baseY + centerOffsetY + 3, centerNode.r);
      fill(centerNode.col);
      ellipse(centerNode.baseX + centerOffsetX, centerNode.baseY + centerOffsetY, centerNode.r);

      push();
      fill(0);
      noStroke();
      textSize(24);
      text(centerNode.label, centerNode.baseX + centerOffsetX, centerNode.baseY + centerOffsetY);
      pop();
    }

    function mousePressed() {
      for (let i = 0; i < surroundingNodes.length; i++) {
        let node = surroundingNodes[i];
        let dx = mouseX - node.currentX;
        let dy = mouseY - node.currentY;
        if (dist(0, 0, dx, dy) < node.r / 2) {
          focusedNodeIndex = i;
          return;
        }
      }
      // אם לוחצים על מקום ריק – ביטול הפוקוס
      focusedNodeIndex = null;
    }

    function distFunc(x1, y1, x2, y2) {
      return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
    }
  </script>
</body>
</html>
